# Introduction

## Problem definition

Enrollment-based analytics requests that reference Program Indicators may, in specific cases, generate SQL queries containing scalar subqueries that reference other **analytics event** tables.

These queries [are not compatible](https://doris.apache.org/docs/3.0/query-data/subquery?_highlight=subquery#limitations-of-nested-subqueries) with Apache Doris/Clickhouse due to their limitations in handling nested subqueries.

Let's take this simple Program Indicator expression:

```
#{ZzYYXq4fJie.GQY2lXrypjO} - #{A03MvHHogjR.UXz7xuGCEhU}
```

The above expression renders as "Baby Postnatal\.MCH Infant Weight (g) - Birth\.MCH Weight (g)".

This is the SQL query that is generated by the Program Indicator expression using Apache Doris as analytics database:

```sql
with RhMRhRzchWd as (
select
	enrollment,
	-- invalid sub-selects
	avg(coalesce(cast((select `GQY2lXrypjO` from analytics_event_IpHINAT79UW
	where analytics_event_IpHINAT79UW.enrollment = subax.enrollment and `GQY2lXrypjO` is not null and ps = 'ZzYYXq4fJie'
	order by occurreddate desc limit 1 ) as DECIMAL), 0)
	- coalesce(cast((select `UXz7xuGCEhU` from analytics_event_IpHINAT79UW where analytics_event_IpHINAT79UW.enrollment = subax.enrollment
	and `UXz7xuGCEhU` is not null and ps = 'A03MvHHogjR' order by occurreddate desc limit 1 ) as DECIMAL), 0)) as value
from
	analytics_enrollment_iphinat79uw as subax
group by
	enrollment )
select
	ax.enrollment,
	...
	yehpx.value as RhMRhRzchWd
from
	analytics_enrollment_iphinat79uw as ax
left join RhMRhRzchWd yehpx on
	yehpx.enrollment = ax.enrollment
where
	(((enrollmentdate >= '1975-01-01'
		and enrollmentdate < '2051-01-01')))
	and (ax.`uidlevel1` = 'ImspTQPwCqd' )
limit 101 offset 0
```

The subquery `select `GQY2lXrypjO`from analytics_event_IpHINAT79UW
	where analytics_event_IpHINAT79UW.enrollment = subax.enrollment and`GQY2lXrypjO` is not null` is invalid in Doris.
Apache Doris throws the following error:

```
correlationFilter can't be null in correlatedToJoin
```

Program Indicatior expressions can be also used as filters. Filters also can generate invalid SQL statements.

Example:

```sql
with RhMRhRzchWd as (
select
	enrollment,
	1 as value
from
	analytics_enrollment_iphinat79uw as subax
	-- where condition is invalid
where
	coalesce(cast((select `GQY2lXrypjO` from analytics_event_IpHINAT79UW where analytics_event_IpHINAT79UW.enrollment = subax.enrollment and `GQY2lXrypjO` is not null and ps = 'ZzYYXq4fJie' order by occurreddate desc limit 1 ) as DECIMAL), 0) != cast(0 as DECIMAL)
group by
	enrollment )
... -- rest of the sql
```

### Postgres

Postgres supports scalar subqueries.

### Variables and Functions

These subqueries are generated when an expression involves one of the following variables or functions:

- `vScheduledDate` (`V{scheduled_date}`)
- `vCreationDate` (`V{creation_date}`)
- `vDueDate` (`V{due_date}`)
- `vEventDate` (`V{event_date}`)
- `vEventStatus` (`V{event_status} == 'OVERDUE'`)
- `d2:countIfValue`
- `d2:countIfCondition`
- `d2:count`
- `ProgramItemStageElement` (`#{program-stage-id.data-element-id})

## Goal

Refactor the SQL generation to replace these specific nested subqueries with Common Table Expressions (CTEs) while maintaining PostgreSQL compatibility and aiming for reasonable performance.

### Architectural Change Enabling the Result

The core architectural change enabling CTE generation for various Program Indicator components involves a **Placeholder and Deferred Processing Mechanism coordinated primarily by `DefaultProgramIndicatorSubqueryBuilder`**:

1.  **Placeholder Emission (Expression Parsing Phase):**

    - Instead of directly generating subqueries deep within the expression parsing logic (`CommonExpressionVisitor` -> `ExpressionItem` implementations), the relevant `ExpressionItem` classes now emit **structured placeholder strings** when generating SQL for Enrollment analytics.
    - **`V{variable}` Items:** (e.g., `V{event_date}`) - Emit `FUNC_CTE_VAR(type='...', column='...', piUid='...', psUid='...', offset='...')`. The `type` helps determine later processing (e.g., conditional coalesce). Handled by classes like `ProgramVariableItem`.
    - **`#{psUid.deUid}` Items:** Emit `__PSDE_CTE_PLACEHOLDER__(psUid='...', deUid='...', offset='...', boundaryHash='...', piUid='...')`. The `boundaryHash` captures the relevant period boundaries active during parsing. Handled by `ProgramItemStageElement`.
    - **`d2:func(...)` Items:** (e.g., `d2:countIfValue(#{ps.de}, val)`) - Emit `__D2FUNC__(func='...', ps='...', de='...', argType='...', arg64='...', hash='...', pi='...')__`. The `argType` indicates if `arg64` holds Base64 encoded value SQL (`val64`) or a condition literal (`condLit64`). Handled by `ProgramCountFunction` and its subclasses (`D2CountIfValue`, `D2CountIfCondition`, `D2Count`).

2.  **Centralized Processing & CTE Generation (Subquery Builder Phase):**

    - The `DefaultProgramIndicatorSubqueryBuilder`, which orchestrates the creation of the main PI CTE and manages the `CteContext`, coordinates the processing of the raw SQL containing these placeholders.
    - **Filter Analysis:** It first calls `ProgramIndicatorPlaceholderUtils.analyzeFilterAndGenerateFilterCtes` to identify simple filter comparisons (`V{var} <op> 'literal'`). For these, specific "Filter CTEs" (`filtercte_...`) are generated, added to `CteContext`, and their aliases noted for later `INNER JOIN`. Any remaining complex filter parts are returned as a string.
    - **Sequential Placeholder Processing:** It then orchestrates calls to static methods in `ProgramIndicatorPlaceholderUtils` to handle the different placeholder types found in the main PI expression and the complex filter string:
      - `processPlaceholdersAndGenerateVariableCtes`: Finds `FUNC_CTE_VAR`, generates "Variable CTEs" (`varcte_...`) using `ROW_NUMBER()`, adds them to `CteContext`, and replaces placeholders with `coalesce(alias.value, default)` (conditionally based on `type`).
      - `processPsDePlaceholdersAndGenerateCtes`: Finds `__PSDE_CTE_PLACEHOLDER__`, generates "PS/DE CTEs" (`psdecte_...`) using `ROW_NUMBER()` and `targetRank` derived from `offset`, adds them to `CteContext`, and replaces placeholders with `coalesce(alias.value, 0)`.
      - `processD2FunctionPlaceholdersAndGenerateCtes`: Finds `__D2FUNC__`, parses embedded metadata (including decoding Base64 argument), generates "D2 Function CTEs" (`d2func_...`) using `COUNT(...) GROUP BY enrollment` and appropriate WHERE conditions based on `argType` and decoded argument, adds them to `CteContext`, and replaces placeholders with `coalesce(alias.value, 0)`.
    - **Join Generation:** It calls `buildLeftJoinsForAllValueCtes`, which reads the populated `CteContext` and generates `LEFT JOIN` clauses for all `VARIABLE`, `PSDE`, and `D2_FUNCTION` CTEs, applying the correct `ON alias.enrollment = subax.enrollment [AND alias.rn = rank]` conditions based on the `CteType`.
    - **Main PI CTE Construction:** Finally, it assembles the SQL for the main PI CTE. This SQL uses the fully processed expression and complex filter strings (with placeholders replaced) and incorporates the generated `INNER JOIN` (for simple filters) and `LEFT JOIN` (for values/functions) clauses.

3.  **Context Management:**
    - The `CteContext` class acts as the central registry for all generated `CteDefinition` objects, keyed by a unique identifier derived from the placeholder content.
    - The `CteDefinition` class uses a `CteType` enum (`VARIABLE`, `PSDE`, `D2_FUNCTION`, `FILTER`, etc.) to distinguish between different CTE types and includes fields like `targetRank` (for PSDE) and `joinColumn` where necessary. It also holds the randomly generated short `alias` used in the final SQL.
    - A method `getAliasAndDefinitionSqlMap()` was added to `CteContext` to provide a mapping of `shortAlias -> cteSqlBody` specifically for the final query builder constructing the `WITH` clause.

This architecture decouples the initial identification and placeholder generation during expression parsing from the later, centralized phase of CTE SQL generation, placeholder replacement, and join construction, all managed within the `DefaultProgramIndicatorSubqueryBuilder` using utilities from `ProgramIndicatorPlaceholderUtils` and the state managed by `CteContext`.

### Example subqueries

#### Type `#{psUid.deUid}`

Before:

```sql
with RhMRhRzchWd as (
select
	enrollment,
	-- invalid sub-selects
	avg(coalesce(cast((select `GQY2lXrypjO` from analytics_event_IpHINAT79UW
	where analytics_event_IpHINAT79UW.enrollment = subax.enrollment and `GQY2lXrypjO` is not null and ps = 'ZzYYXq4fJie'
	order by occurreddate desc limit 1 ) as DECIMAL), 0)
	- coalesce(cast((select `UXz7xuGCEhU` from analytics_event_IpHINAT79UW where analytics_event_IpHINAT79UW.enrollment = subax.enrollment
	and `UXz7xuGCEhU` is not null and ps = 'A03MvHHogjR' order by occurreddate desc limit 1 ) as DECIMAL), 0)) as value
from
	analytics_enrollment_iphinat79uw as subax
group by
	enrollment )
select
	ax.enrollment,
	...
	yehpx.value as RhMRhRzchWd
```

After: the two subqueries are transformed into two separate CTEs and referenced into the main CTE holding the expression.

```sql
with rwhmy as (
select
	enrollment,
	`GQY2lXrypjO` as value,
	row_number() over (partition by enrollment
order by
	`occurreddate` desc) as rn
from
	analytics_event_IpHINAT79UW
where
	`GQY2lXrypjO` is not null
	and ps = 'ZzYYXq4fJie'
	and `enrollmentdate` < '2051-01-01'
	and `enrollmentdate` >= '1975-01-01' ),
qvqnc as (
select
	enrollment,
	`UXz7xuGCEhU` as value,
	row_number() over (partition by enrollment
order by
	`occurreddate` desc) as rn
from
	analytics_event_IpHINAT79UW
where
	`UXz7xuGCEhU` is not null
	and ps = 'A03MvHHogjR'
	and `enrollmentdate` < '2051-01-01'
	and `enrollmentdate` >= '1975-01-01' ),
	RhMRhRzchWd as (
select
		subax.enrollment,
		avg(coalesce(rwhmy.value, 0) - coalesce(qvqnc.value, 0)) as value
from
		analytics_enrollment_iphinat79uw as subax
left join rwhmy rwhmy on
		rwhmy.enrollment = subax.enrollment
		and rwhmy.rn = 1
left join qvqnc qvqnc on
		qvqnc.enrollment = subax.enrollment
		and qvqnc.rn = 1
group by
		subax.enrollment )
select ...
```

#### Type `V{variable}`

Example: `d2:yearsBetween(V{creation_date}, V{enrollment_date}) >= 5 `

Before:

```sql
with RhMRhRzchWd as (
select
	subax.enrollment,
	avg(cast(1 as DECIMAL) + cast(1 as DECIMAL)) as value
from
	analytics_enrollment_iphinat79uw as subax
where
	TIMESTAMPDIFF(year, (select created from analytics_event_IpHINAT79UW
						where analytics_event_IpHINAT79UW.enrollment = subax.enrollment
						and created is not null order by occurreddate desc limit 1 ), enrollmentdate) >= cast(5 as DECIMAL)
group by
	subax.enrollment )
select...
```

After:

```sql
with ecowm as (
select
	enrollment,
	`created` as value,
	row_number() over (partition by enrollment
order by
	occurreddate desc) as rn
from
	analytics_event_IpHINAT79UW
where
	`created` is not null
	and `enrollmentdate` < '2051-01-01'
	and `enrollmentdate` >= '1975-01-01' ),
RhMRhRzchWd as (
select
	subax.enrollment,
	avg(cast(1 as DECIMAL) + cast(1 as DECIMAL)) as value
from
	analytics_enrollment_iphinat79uw as subax
left join ecowm ecowm on
	ecowm.enrollment = subax.enrollment
	and ecowm.rn = 1
where
	TIMESTAMPDIFF(year, ecowm.value, enrollmentdate) >= cast(5 as DECIMAL)
group by
	subax.enrollment )
select ...
```

---

expression
#{ZzYYXq4fJie.GQY2lXrypjO} - #{A03MvHHogjR.UXz7xuGCEhU}
